#include <WiFi.h>
#include <HTTPClient.h>
#include <time.h>
#include <math.h>
#include "esp_sleep.h"

/* ============================================
   AUTO MODE:
   - AUTO_TEST_MODE = true  ‚Üí test trong nh√† (ƒëo tr·ª±c ti·∫øp)
   - AUTO_TEST_MODE = false ‚Üí ch·∫°y th·ª±c t·∫ø (Water Signature + l·ªçc)
============================================ */
bool AUTO_TEST_MODE = true;          // m·∫∑c ƒë·ªãnh ban ƒë·∫ßu
unsigned long autoModeLastSwitch = 0;
const unsigned long AUTO_MIN_DURATION = 20000;  // 20 gi√¢y ·ªïn ƒë·ªãnh ƒë·ªÉ ƒë·ªïi mode

/* ============================================
   WIFI CONFIG
============================================ */
const char* WIFI_SSID     = "XN Tay Nam";
const char* WIFI_PASSWORD = "xinghieptn";

/* ============================================
   FIREBASE CONFIG
============================================ */
const char* FIREBASE_URL    = "https://tram-do-1-default-rtdb.asia-southeast1.firebasedatabase.app";
const char* FIREBASE_SECRET = "pMjprlSeXPhcOA63bPTcqjlRLjyx0zrnsWqo";

const char* STATION_ID = "station01";

/* ============================================
   IFTTT CONFIG
============================================ */
String IFTTT_KEY   = "cBaUhQOLfjOPn4ztdp4RtO";
String IFTTT_EVENT = "flood_alert";

bool iftttAlertSent = false;
unsigned long lastAlertTime = 0;
const unsigned long ALERT_INTERVAL = 10UL * 60UL * 1000UL;

/* ============================================
   SENSOR
============================================ */
#define TRIG 5
#define ECHO 18

/* ============================================
   GEOMETRY & AUTO-CALIBRATION
   baselineDistance = kho·∫£ng c√°ch ƒëo khi KH√îNG c√≥ n∆∞·ªõc
   M·ª±c n∆∞·ªõc = baselineDistance - D
============================================ */
const float BASELINE_DEFAULT = 35.0f;   // t·∫°m coi kho·∫£ng 35cm
float baselineDistance = BASELINE_DEFAULT;
const float BASELINE_ALPHA = 0.02f;     // h·ªá s·ªë l·ªçc ch·∫≠m baseline
unsigned long lastBaselineUpdate = 0;
const unsigned long BASELINE_UPDATE_INTERVAL = 30000; // 30s

/* ============================================
   CONSTANTS
============================================ */
const int SIDEWALK_H = 15;          // cao l·ªÅ (cm)
const unsigned long LOOP_PERIOD = 10000; // ms

/* ============================================
   STATE
============================================ */
long lastWaterLevel = 0;
unsigned long lastMeasureTime = 0;

bool isFlooding = false;
unsigned long floodStartTime = 0;

unsigned long lastHistorySave = 0;

/* ============================================
   WATER SIGNATURE (REAL MODE)
============================================ */
long filteredWater = 0;

int waterStableCount = 0;
int dryStableCount   = 0;

float lastFiltered = 0.0f;
unsigned long lastMovementTime = 0;

const int WATER_TRIGGER = 3;        // k√≠ch ho·∫°t n∆∞·ªõc
const int FILTER_COUNT  = 5;        // c·∫ßn 5 m·∫´u li√™n ti·∫øp
const float WATER_MIN_FLUCT = 0.3;  // dao ƒë·ªông >= 0.3 cm
const unsigned long MAX_STATIC_TIME = 30000;

/* ============================================
   "AI" L·ªåC NHI·ªÑU (d·ª±a tr√™n t·ªëc ƒë·ªô thay ƒë·ªïi)
   - Lo·∫°i b·ªè spike qu√° nhanh (v·∫≠t c·∫£n, xe ch·∫°y ngang)
============================================ */
long lastRawForAI = 0;
unsigned long lastRawTimeForAI = 0;
const float AI_MAX_SPEED_CM_PER_S = 20.0f;  // >20cm/s coi l√† spike nhi·ªÖu

bool aiAcceptSample(long rawW, unsigned long nowMs) {
  if (lastRawTimeForAI == 0) {
    lastRawTimeForAI = nowMs;
    lastRawForAI = rawW;
    return true;
  }
  float dt = (nowMs - lastRawTimeForAI) / 1000.0f;
  if (dt <= 0) dt = 0.001f;
  float delta = fabs((float)rawW - (float)lastRawForAI);
  float speed = delta / dt;  // cm/s

  lastRawTimeForAI = nowMs;
  lastRawForAI = rawW;

  if (speed > AI_MAX_SPEED_CM_PER_S) {
    Serial.print("[AI] Spike b·ªã lo·∫°i, speed=");
    Serial.println(speed);
    return false;
  }
  return true;
}

/* ============================================
   WIFI CONNECT
============================================ */
void connectWiFi() {
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  Serial.print("WiFi connecting");
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print(".");
    delay(400);
  }
  Serial.println(" ‚Üí OK");
}

/* ============================================
   SENSOR READ
============================================ */
long getDistance() {
  digitalWrite(TRIG, LOW);
  delayMicroseconds(5);
  digitalWrite(TRIG, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG, LOW);

  long duration = pulseIn(ECHO, HIGH, 30000);
  long d = duration * 0.034 / 2;
  if (d < 2 || d > 450) {
    // gi√° tr·ªã b·∫•t th∆∞·ªùng, gi·ªØ nguy√™n
  }
  return d;
}

/* ============================================
   AUTO CALIBRATION BASELINE
   - Ch·ªâ update khi:
     + TEST_MODE
     + rawW g·∫ßn 0
     + dao ƒë·ªông nh·ªè
============================================ */
void updateBaselineAuto(long D, long rawW) {
  unsigned long now = millis();

  if (!AUTO_TEST_MODE) return;

  if (rawW > WATER_TRIGGER) return; // c√≥ th·ªÉ ƒë√£ c√≥ n∆∞·ªõc

  if (now - lastBaselineUpdate < BASELINE_UPDATE_INTERVAL) return;

  // n·ªÅn kh√¥ ‚Üí baselineDistance ~ D
  float newBase = (float)D;
  baselineDistance = (1.0f - BASELINE_ALPHA) * baselineDistance
                     + BASELINE_ALPHA * newBase;
  lastBaselineUpdate = now;

  Serial.print("[CALIB] baselineDistance updated = ");
  Serial.println(baselineDistance);
}

/* ============================================
   AUTO MODE DECISION
============================================ */
bool waterStable(float diff) {
  return diff < WATER_MIN_FLUCT;
}

void decideAutoMode(long rawW) {
  unsigned long now = millis();
  float diff = fabs((float)rawW - lastFiltered);

  // ƒêi·ªÅu ki·ªán v√†o TEST_MODE:
  // - m·ª±c n∆∞·ªõc r·∫•t th·∫•p
  // - ho·∫∑c dao ƒë·ªông < 0.3cm
  if (rawW < WATER_TRIGGER || waterStable(diff)) {
    if (!AUTO_TEST_MODE && now - autoModeLastSwitch > AUTO_MIN_DURATION) {
      AUTO_TEST_MODE = true;
      autoModeLastSwitch = now;
      Serial.println("üîÑ AUTO MODE ‚Üí TEST_MODE (n∆∞·ªõc ƒë·ª©ng y√™n / m√¥i tr∆∞·ªùng test)");
    }
    return;
  }

  // ƒêi·ªÅu ki·ªán v√†o REAL_MODE:
  if (!waterStable(diff) && rawW >= WATER_TRIGGER) {
    if (AUTO_TEST_MODE && now - autoModeLastSwitch > AUTO_MIN_DURATION) {
      AUTO_TEST_MODE = false;
      autoModeLastSwitch = now;
      Serial.println("üîÑ AUTO MODE ‚Üí REAL_MODE (ph√°t hi·ªán n∆∞·ªõc dao ƒë·ªông th·∫≠t)");
    }
  }
}

/* ============================================
   WATER FILTER (AUTO MODE)
============================================ */
void updateWaterFilter(long rawW) {
  unsigned long now = millis();

  // AI l·ªçc spike tr∆∞·ªõc
  if (!aiAcceptSample(rawW, now)) {
    // B·ªè qua m·∫´u n√†y, kh√¥ng c·∫≠p nh·∫≠t filteredWater
    return;
  }

  // Quy·∫øt ƒë·ªãnh mode
  decideAutoMode(rawW);

  // ===========================
  // TEST MODE ‚Äì hi·ªÉn th·ªã rawW
  // ===========================
  if (AUTO_TEST_MODE) {
    filteredWater = rawW;
    return;
  }

  // ===========================
  // REAL MODE ‚Äì n∆∞·ªõc th·∫≠t ngo√†i tr·ªùi
  // ===========================
  float current = (float)rawW;

  if (current < WATER_TRIGGER) {
    dryStableCount++;
    waterStableCount = 0;

    if (dryStableCount >= FILTER_COUNT) {
      filteredWater = 0;
      lastFiltered  = 0;
      lastMovementTime = now;
    }
    return;
  }

  float diff = fabs(current - lastFiltered);

  if (diff >= WATER_MIN_FLUCT) {
    waterStableCount++;
    dryStableCount = 0;
    lastMovementTime = now;

    if (waterStableCount >= FILTER_COUNT) {
      filteredWater = rawW;
      lastFiltered = current;
    }
  } else {
    if (filteredWater > 0 && (now - lastMovementTime) > MAX_STATIC_TIME) {
      Serial.println("[SIG] static obstacle ‚Üí reset water");
      filteredWater = 0;
      waterStableCount = 0;
      dryStableCount = FILTER_COUNT;
      lastFiltered = 0;
      lastMovementTime = now;
    } else {
      dryStableCount++;
    }
  }
}

/* ============================================
   FLOOD LEVEL
============================================ */
int getFloodLevel(long w) {
  if (w < 5)  return 0;
  if (w < 10) return 1;
  if (w < 15) return 2;
  return 3;
}

/* ============================================
   IFTTT
============================================ */
void sendIFTTT(long w, long road, float rise, float fall, float dur, bool over) {
  if (WiFi.status() != WL_CONNECTED) return;

  HTTPClient http;
  String url = "https://maker.ifttt.com/trigger/" + IFTTT_EVENT + "/with/key/" + IFTTT_KEY;
  http.begin(url);
  http.addHeader("Content-Type", "application/x-www-form-urlencoded");

  String msg =
    "‚ö†Ô∏è NG·∫¨P N∆Ø·ªöC\n"
    "M·ª±c n∆∞·ªõc: " + String(w) + " cm\n"
    "Ng·∫≠p m·∫∑t ƒë∆∞·ªùng: " + String(road) + " cm\n"
    "D√¢ng: " + String(rise,2) + " cm/ph√∫t\n"
    "R√∫t: " + String(fall,2) + " cm/ph√∫t\n"
    "Th·ªùi gian ng·∫≠p: " + String(dur,1) + " ph√∫t\n"
    "Tr√†n l·ªÅ: " + String(over ? "C√ì" : "Kh√¥ng");

  int code = http.POST("value1=" + msg);
  Serial.print("IFTTT: ");
  Serial.println(code);

  http.end();
}

/* ============================================
   SEND REALTIME
============================================ */
void sendRealtime(long D, long w, long road, float rise, float fall,
                  float dur, bool over, int level)
{
  HTTPClient http;

  String url = String(FIREBASE_URL) + "/stations/" + STATION_ID + ".json?auth=" + FIREBASE_SECRET;
  http.begin(url);
  http.addHeader("Content-Type", "application/json");

  unsigned long nowSec = millis() / 1000;

  String js = "{";
  js += "\"distance\":" + String(D) + ",";
  js += "\"water_level\":" + String(w) + ",";
  js += "\"road_flood\":" + String(road) + ",";
  js += "\"rise_rate\":" + String(rise, 2) + ",";
  js += "\"fall_rate\":" + String(fall, 2) + ",";
  js += "\"over_sidewalk\":" + String(over ? 1 : 0) + ",";
  js += "\"flood_duration\":" + String(dur, 1) + ",";
  js += "\"flood_level\":" + String(level) + ",";
  js += "\"lat\":10.77563018,";
  js += "\"lng\":106.6555787,";
  js += "\"name\":\"Tr·∫°m 01 - QL50\",";
  js += "\"address\":\"Qu·ªëc L·ªô 50 - B√¨nh Ch√°nh\",";
  js += "\"last_update\":" + String(nowSec);
  js += "}";

  int code = http.PUT(js);
  Serial.print("Realtime: ");
  Serial.println(code);

  http.end();
}

/* ============================================
   SAVE HISTORY
============================================ */
void saveHistory(long w, long road, float rise, float fall,
                 float dur, bool over, int level)
{
  time_t nowTime = time(NULL);
  struct tm *t = localtime(&nowTime);

  char dateStr[16], timeStr[16];
  sprintf(dateStr, "%04d-%02d-%02d", t->tm_year+1900, t->tm_mon+1, t->tm_mday);
  sprintf(timeStr, "%02d:%02d", t->tm_hour, t->tm_min);

  String url = String(FIREBASE_URL) +
               "/history/" + STATION_ID + "/" +
               dateStr + "/" + timeStr + ".json?auth=" + FIREBASE_SECRET;

  HTTPClient http;
  http.begin(url);
  http.addHeader("Content-Type","application/json");

  String js = "{";
  js += "\"water_level\":" + String(w) + ",";
  js += "\"road_flood\":" + String(road) + ",";
  js += "\"rise_rate\":" + String(rise, 2) + ",";
  js += "\"fall_rate\":" + String(fall, 2) + ",";
  js += "\"over_sidewalk\":" + String(over ? 1 : 0) + ",";
  js += "\"flood_duration\":" + String(dur, 1);
  js += "}";

  int code = http.PUT(js);
  Serial.print("History: ");
  Serial.println(code);

  http.end();
}

/* ============================================
   EVENTS
============================================ */
void saveEvent(const char* eventKey, long w, long road)
{
  time_t nowTime = time(NULL);
  struct tm *t = localtime(&nowTime);

  char dateStr[16], timeStr[16];
  sprintf(dateStr, "%04d-%02d-%02d", t->tm_year+1900, t->tm_mon+1, t->tm_mday);
  sprintf(timeStr, "%02d:%02d", t->tm_hour, t->tm_min);

  String url = String(FIREBASE_URL) +
               "/events/" + STATION_ID + "/" +
               dateStr + "/" + eventKey + ".json?auth=" + FIREBASE_SECRET;

  HTTPClient http;
  http.begin(url);
  http.addHeader("Content-Type","application/json");

  String js = "{";
  js += "\"time\":\"" + String(timeStr) + "\",";
  js += "\"timestamp\":" + String((unsigned long)nowTime) + ",";
  js += "\"water_level\":"+String(w)+",";
  js += "\"road_flood\":"+String(road);
  js += "}";

  int code = http.PUT(js);

  Serial.print("Event ");
  Serial.print(eventKey);
  Serial.print(": ");
  Serial.println(code);

  http.end();
}

/* ============================================
   DEEP SLEEP TI·∫æT KI·ªÜM PIN
   - Ch·ªâ ng·ªß khi:
     + AUTO_TEST_MODE = true (test / kh√¥)
     + filteredWater = 0
============================================ */
const unsigned long DRY_BEFORE_SLEEP = 60000; // kh√¥ 60s r·ªìi m·ªõi cho ng·ªß
unsigned long firstDryTime = 0;

void maybeDeepSleep(long w) {
  unsigned long now = millis();

  if (!AUTO_TEST_MODE) {
    firstDryTime = 0;
    return;
  }
  if (w > 0) {
    firstDryTime = 0;
    return;
  }

  if (firstDryTime == 0) {
    firstDryTime = now;
  }

  if (now - firstDryTime > DRY_BEFORE_SLEEP) {
    Serial.println("üí§ Deep sleep 30s (kh√¥ng n∆∞·ªõc, AUTO_TEST_MODE)");
    esp_sleep_enable_timer_wakeup(30ULL * 1000000ULL);
    esp_deep_sleep_start();
  }
}

/* ============================================
   SETUP
============================================ */
void setup() {
  Serial.begin(115200);
  pinMode(TRIG, OUTPUT);
  pinMode(ECHO, INPUT);

  connectWiFi();
  configTime(7*3600,0,"pool.ntp.org","time.nist.gov");

  lastMovementTime = millis();
  baselineDistance = BASELINE_DEFAULT;

  Serial.println("üöÄ ESP32 Started ‚Äì AUTO MODE + AUTO H + AI FILTER + DEEP SLEEP");
}

/* ============================================
   LOOP
============================================ */
void loop() {
  unsigned long now = millis();
  if (WiFi.status() != WL_CONNECTED) connectWiFi();

  long D = getDistance();

  // t√≠nh m·ª±c n∆∞·ªõc theo baselineDistance
  long rawW = (long)(baselineDistance - (float)D);
  if (rawW < 0) rawW = 0;

  // auto-calib baseline khi kh√¥
  updateBaselineAuto(D, rawW);

  // c·∫≠p nh·∫≠t l·ªçc & AUTO MODE
  updateWaterFilter(rawW);
  long w = filteredWater;

  long road = w;
  bool over = w >= SIDEWALK_H;

  float dur = 0;
  if (w > 0) {
    if (!isFlooding) {
      isFlooding = true;
      floodStartTime = now;
      saveEvent("start_rain", w, road);
      saveEvent("start_flood", w, road);
    }
    dur = (now - floodStartTime) / 60000.0f;
  } else {
    if (isFlooding) {
      saveEvent("end_rain", w, road);
      saveEvent("end_flood", w, road);
      isFlooding = false;
    }
    floodStartTime = now;
  }

  float rise = 0, fall = 0;
  if (lastMeasureTime > 0) {
    float dt = (now - lastMeasureTime) / 60000.0f;
    if (dt > 0) {
      float diff = (float)w - (float)lastWaterLevel;
      if (diff > 0) rise = diff / dt;
      else if (diff < 0) fall = -diff / dt;
    }
  }

  lastMeasureTime = now;
  lastWaterLevel = w;

  int level = getFloodLevel(w);

  sendRealtime(D, w, road, rise, fall, dur, over, level);

  if (now - lastHistorySave > 60000) {
    lastHistorySave = now;
    saveHistory(w, road, rise, fall, dur, over, level);
  }

  if (over) {
    if (!iftttAlertSent || now - lastAlertTime > ALERT_INTERVAL) {
      sendIFTTT(w, road, rise, fall, dur, over);
      iftttAlertSent = true;
      lastAlertTime = now;
    }
  } else {
    iftttAlertSent = false;
  }

  Serial.print("MODE=");
  Serial.print(AUTO_TEST_MODE ? "TEST" : "REAL");
  Serial.print("  D=");
  Serial.print(D);
  Serial.print("  baseline=");
  Serial.print(baselineDistance);
  Serial.print("  rawW=");
  Serial.print(rawW);
  Serial.print("  filtered=");
  Serial.println(w);

  // deep sleep n·∫øu ƒëi·ªÅu ki·ªán kh√¥ & test mode
  maybeDeepSleep(w);

  delay(LOOP_PERIOD);
}
